import React from 'react';
// components
import { Database } from 'components/App';
// utilities
import { setKeyValue } from 'utilities';
// databases
import firebase, { version } from 'config/firebase';

type Props = {
  db: Database;
  userId: string | null;
  children: React.ReactNode;
};

export type BlockProps = {
  id: string;
  meta: { time: number; title: string; desc: string };
  type: 'plainText' | 'richText';
  body: string;
};

type Context = {
  blocks: BlockProps[];
  addBlock(): string;
  removeBlock(blockId: string): void;
  updateBlockFieldText(blockId: string, field: string, text: string): void;
};

const BlocksContext = React.createContext<Context | undefined>(undefined);

function useBlocksContext() {
  const context = React.useContext(BlocksContext);
  if (context === undefined) {
    throw new Error('useBlocksContext must be used within a BlocksProvider');
  }
  return context;
}

function BlocksProvider({ db, userId, children }: Props) {
  const [blocks, setBlocks] = React.useState<BlockProps[]>([]);

  // firebase db reference to user
  const dbUser =
    db === 'firebase' && userId
      ? firebase.database().ref(`version/${version}/users/${userId}`)
      : null;

  // firebase db reference to user's blocks
  const dbBlocks = dbUser ? dbUser.child('blocks') : null;

  function addBlock(): string {
    const time = new Date().getTime();
    let blockId = time.toString();

    if (db === 'memory') {
      setBlocks((blocks) => {
        return blocks.concat({
          id: blockId,
          meta: { time, title: '', desc: '' },
          type: 'plainText',
          body: '',
        });
      });
    }

    if (db === 'firebase') {
      if (!dbBlocks) return blockId;

      const block = dbBlocks.push({
        // id: blockId,
        meta: { time, title: '', desc: '' },
        type: 'plainText',
        body: '',
      });

      if (block.key) blockId = block.key;
    }

    return blockId;
  }

  function removeBlock(blockId: string): void {
    if (db === 'memory') {
      setBlocks((blocks) => {
        return blocks.filter((block) => block.id !== blockId);
      });
    }

    if (db === 'firebase') {
      if (!dbBlocks) return;

      const block = dbBlocks.child(blockId);
      block.remove();
    }
  }

  function updateBlockFieldText(
    blockId: string,
    field: string,
    text: string,
  ): void {
    const fields = field.split('.'); // 'meta.title' -> ['meta', 'title']

    if (db === 'memory') {
      setBlocks((blocks) => {
        const updatedBlocks = [...blocks];
        const block = updatedBlocks.filter((block) => block.id === blockId)[0];
        setKeyValue(block, fields, text);
        return updatedBlocks;
      });
    }

    if (db === 'firebase') {
      if (!dbBlocks) return;

      const path = fields.join('/'); // ['meta', 'title'] -> 'meta/title'
      dbBlocks.child(`${blockId}/${path}`).set(text);
    }
  }

  // initialize blocks from firebase databse after first render
  const [blocksInitialized, setBlocksInitialized] = React.useState(false);
  React.useEffect(() => {
    if (db !== 'firebase') return;
    if (blocksInitialized) return;
    if (!dbBlocks) return;

    dbBlocks.on('value', (snapshot) => {
      const blocksObject = snapshot.val();
      // firebase stores everything as objects, so we need to convert the blocks
      // object back to an array (key is the key auto-generated by firebase)
      const blocks = Object.keys(blocksObject).map((key) => {
        const block = blocksObject[key];
        return {
          id: key,
          meta: block.meta,
          type: block.type,
          body: block.body,
        };
      });

      setBlocksInitialized(true);
      setBlocks(blocks);
    });
  }, [db, dbBlocks, blocksInitialized]);

  return (
    <BlocksContext.Provider
      value={{ blocks, addBlock, removeBlock, updateBlockFieldText }}
    >
      {children}
    </BlocksContext.Provider>
  );
}

export { BlocksProvider, useBlocksContext };
