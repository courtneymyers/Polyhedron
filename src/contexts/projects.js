// @flow

import React from 'react';
// types
import type { Node } from 'react';
import type { Database } from 'components/App';
// utilities
import { setKeyValue } from 'utilities';
// databases
import firebase from 'databases/firebase.js';

// --- contexts
export const ProjectsContext = React.createContext();

// --- components
type Props = {|
  db: Database,
  children: Node,
|};

type ProjectMeta = {|
  time: number,
  title: string,
  desc: string,
|};

export type ProjectProps = {|
  id: string,
  meta: ProjectMeta,
  blockIds: Array<string>,
|};

type State = {|
  projects: Array<ProjectProps>,
  activeProjectId: string,
|};

export class ProjectsProvider extends React.Component<Props, State> {
  dbProjects: Object; // firebase database reference
  dbActiveProject: Object; // firebase database reference
  addProject: () => void;
  removeProject: (string) => void;
  updateProjectFieldText: (string, string, string) => void;
  setActiveProjectId: (string) => void;
  addBlockIdToProject: (string, string, ?number) => void;
  removeBlockIdFromProject: (string, string) => void;
  removeBlockIdFromAllProjects: (string) => void;
  reorderBlocksInProject: (string, number, number) => void;

  constructor(props: Props) {
    super(props);
    this.state = {
      projects: [],
      activeProjectId: '',
    };

    this.dbProjects = firebase.database().ref('projects');
    this.dbActiveProject = firebase.database().ref('activeProject');

    this.addProject = () => {
      const currentTime = new Date().getTime();

      if (this.props.db === 'memory') {
        this.setState((prevState) => ({
          projects: prevState.projects.concat({
            id: currentTime.toString(),
            meta: {
              time: currentTime,
              title: '',
              desc: '',
            },
            blockIds: [],
          }),
          activeProjectId: currentTime.toString(),
        }));
      }

      if (this.props.db === 'firebase') {
        const newProject = this.dbProjects.push({
          meta: {
            time: currentTime,
            title: '',
            desc: '',
          },
        });

        this.dbActiveProject.set(newProject.key);
      }
    };

    this.removeProject = (projectId) => {
      if (this.props.db === 'memory') {
        this.setState((prevState) => ({
          projects: prevState.projects.filter((p) => p.id !== projectId),
        }));
      }

      if (this.props.db === 'firebase') {
        const dbProject = this.dbProjects.child(projectId);
        dbProject.remove();
      }
    };

    this.updateProjectFieldText = (projectId, field, text) => {
      const fields = field.split('.'); // 'meta.title' -> ['meta', 'title']

      if (this.props.db === 'memory') {
        this.setState((prevState) => {
          const projects = [...prevState.projects];
          const project = projects.filter((p) => p.id === projectId)[0];
          setKeyValue(project, fields, text);

          return {
            projects: projects,
          };
        });
      }

      if (this.props.db === 'firebase') {
        const path = fields.join('/'); // ['meta', 'title'] -> 'meta/title'
        this.dbProjects.child(`${projectId}/${path}`).set(text);
      }
    };

    this.setActiveProjectId = (projectId) => {
      if (this.props.db === 'memory') {
        this.setState((prevState) => ({
          activeProjectId: projectId,
        }));
      }

      if (this.props.db === 'firebase') {
        this.dbActiveProject.set(projectId);
      }
    };

    this.addBlockIdToProject = (projectId, blockId, toIndex) => {
      if (this.props.db === 'memory') {
        this.setState((prevState) => {
          const projects = [...prevState.projects];
          const project = projects.filter((p) => p.id === projectId)[0];
          // if toIndex (third argument) isn't passed to method,
          // set toIndex so block will be added to the end
          if (!toIndex) toIndex = project.blockIds.length;
          // insert block at toIndex
          project.blockIds.splice(toIndex, 0, blockId);

          return {
            projects: projects,
          };
        });
      }

      if (this.props.db === 'firebase') {
        const dbBlockIds = this.dbProjects.child(`${projectId}/blockIds`);
        // add blockId to the end of the project's blockIds array
        dbBlockIds.push(blockId);
        // if toIndex (third argument) isn't passed to method, we're done
        // else, we need to re-order the project's blockIds
        if (toIndex === undefined) return;
        // firebase stores everything as objects, so we need to convert the
        // blockIds data back to an array by iterating over each object's key
        // (blockIdsKey below is the key auto-generated by firebase)
        let blockIdsArray = [];
        dbBlockIds.on('value', (snapshot) => {
          const blockIds = snapshot.val();
          for (let blockIdsKey in blockIds) {
            blockIdsArray.push(blockIds[blockIdsKey]);
          }
        });
        // null/undefined check for flow (toIndex will always be a number here)
        if (toIndex !== null && toIndex !== undefined) {
          // remove blockId from end, and re-insert back at toIndex
          blockIdsArray.splice(-1, 1);
          blockIdsArray.splice(toIndex, 0, blockId);
        }
        // store re-ordered blockIds in firebase
        dbBlockIds.remove();
        blockIdsArray.forEach((blockId) => dbBlockIds.push(blockId));
      }
    };

    this.removeBlockIdFromProject = (projectId, blockId) => {
      if (this.props.db === 'memory') {
        this.setState((prevState) => {
          const projects = [...prevState.projects];
          const project = projects.filter((p) => p.id === projectId)[0];
          const updatedBlockIds = project.blockIds.filter(
            (id) => id !== blockId,
          );
          project.blockIds = updatedBlockIds;

          return {
            projects: projects,
          };
        });
      }

      if (this.props.db === 'firebase') {
        this.dbProjects
          .child(`${projectId}/blockIds`)
          .orderByValue()
          .equalTo(blockId)
          .once('child_added', (snapshot) => {
            snapshot.ref.remove();
          });
      }
    };

    this.removeBlockIdFromAllProjects = (blockId) => {
      if (this.props.db === 'memory') {
        this.setState((prevState) => {
          const projects = [...prevState.projects];
          projects.map((project) => {
            project.blockIds = project.blockIds.filter((id) => id !== blockId);
            return project;
          });

          return {
            projects: projects,
          };
        });
      }

      if (this.props.db === 'firebase') {
        this.state.projects.forEach((project) => {
          this.dbProjects
            .child(`${project.id}/blockIds`)
            .orderByValue()
            .equalTo(blockId)
            .once('child_added', (snapshot) => {
              snapshot.ref.remove();
            });
        });
      }
    };

    this.reorderBlocksInProject = (projectId, fromIndex, toIndex) => {
      if (this.props.db === 'memory') {
        this.setState((prevState) => {
          const projects = [...prevState.projects];
          const project = projects.filter((p) => p.id === projectId)[0];
          // remove block at fromIndex, and re-insert back at toIndex
          const blockId = project.blockIds.splice(fromIndex, 1)[0];
          project.blockIds.splice(toIndex, 0, blockId);

          return {
            projects: projects,
          };
        });
      }

      if (this.props.db === 'firebase') {
        const dbBlockIds = this.dbProjects.child(`${projectId}/blockIds`);
        // firebase stores everything as objects, so we need to convert the
        // blockIds data back to an array by iterating over each object's key
        // (blockIdsKey below is the key auto-generated by firebase)
        let blockIdsArray = [];
        dbBlockIds.on('value', (snapshot) => {
          const blockIds = snapshot.val();
          for (let blockIdsKey in blockIds) {
            blockIdsArray.push(blockIds[blockIdsKey]);
          }
        });
        // remove block at fromIndex, and re-insert back at toIndex
        const blockId = blockIdsArray.splice(fromIndex, 1)[0];
        blockIdsArray.splice(toIndex, 0, blockId);
        // store re-ordered blockIds in firebase
        dbBlockIds.remove();
        blockIdsArray.forEach((blockId) => dbBlockIds.push(blockId));
      }
    };
  }

  componentDidMount() {
    if (this.props.db === 'firebase') {
      this.dbProjects.on('value', (snapshot) => {
        const projects = snapshot.val();
        // firebase stores everything as objects, so we need to convert the
        // projects data back to an array by iterating over each object's key
        // (projectsKey below is the key auto-generated by firebase)
        let updatedProjects = [];
        for (let projectsKey in projects) {
          const project = projects[projectsKey];

          // same song and dance for building up blockIds array...
          // (blocksIdKey below is the key auto-generated by firebase)
          let blockIds = [];
          for (let blocksIdKey in project.blockIds) {
            blockIds.push(project.blockIds[blocksIdKey]);
          }

          updatedProjects.push({
            id: projectsKey,
            meta: project.meta,
            blockIds: blockIds,
          });
        }

        this.setState((prevState) => ({
          projects: updatedProjects,
        }));
      });

      this.dbActiveProject.on('value', (snapshot) => {
        this.setState((prevState) => ({
          activeProjectId: snapshot.val(),
        }));
      });
    }
  }

  render() {
    return (
      <ProjectsContext.Provider
        value={{
          ...this.state,
          addProject: this.addProject,
          removeProject: this.removeProject,
          updateProjectFieldText: this.updateProjectFieldText,
          setActiveProjectId: this.setActiveProjectId,
          addBlockIdToProject: this.addBlockIdToProject,
          removeBlockIdFromProject: this.removeBlockIdFromProject,
          removeBlockIdFromAllProjects: this.removeBlockIdFromAllProjects,
          reorderBlocksInProject: this.reorderBlocksInProject,
        }}
      >
        {this.props.children}
      </ProjectsContext.Provider>
    );
  }
}
