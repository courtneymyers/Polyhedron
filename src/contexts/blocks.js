// @flow

import React from 'react';
import type { Node } from 'react';
// types
import type { Database } from 'components/App';
// utilities
import { setKeyValue } from 'utilities';
// databases
import firebase, { version } from 'config/firebase';

const BlocksContext: any = React.createContext();

type Props = {
  db: Database,
  userId: ?string,
  children: Node,
};

type BlockProps = {
  id: string,
  meta: { time: number, title: string, desc: string },
  type: 'plainText' | 'richText',
  body: string,
};

function BlocksProvider({ db, userId, children }: Props) {
  const [blocks, setBlocks] = React.useState<BlockProps[]>([]);

  // firebase db reference to user's blocks
  const dbBlocks =
    db === 'firebase' && userId
      ? firebase
          .database()
          .ref(`version/${version}/users/${userId}`)
          .child('blocks')
      : null;

  function addBlock(): string {
    const time = new Date().getTime();
    let blockId = time.toString();

    if (db === 'memory') {
      setBlocks((blocks) => {
        return blocks.concat({
          id: blockId,
          meta: { time, title: '', desc: '' },
          type: 'plainText',
          body: '',
        });
      });
    }

    if (db === 'firebase') {
      const block = dbBlocks.push({
        // id: blockId,
        meta: { time, title: '', desc: '' },
        type: 'plainText',
        body: '',
      });

      blockId = block.key;
    }

    return blockId;
  }

  function removeBlock(blockId: string): void {
    if (db === 'memory') {
      setBlocks((blocks) => {
        return blocks.filter((block) => block.id !== blockId);
      });
    }

    if (db === 'firebase') {
      const block = dbBlocks.child(blockId);
      block.remove();
    }

    return null;
  }

  function updateBlockFieldText(
    blockId: string,
    field: string,
    text: string,
  ): void {
    const fields = field.split('.'); // 'meta.title' -> ['meta', 'title']

    if (db === 'memory') {
      setBlocks((blocks) => {
        const updatedBlocks = [...blocks];
        const block = updatedBlocks.filter((block) => block.id === blockId)[0];
        setKeyValue(block, fields, text);
        return updatedBlocks;
      });
    }

    if (db === 'firebase') {
      const path = fields.join('/'); // ['meta', 'title'] -> 'meta/title'
      dbBlocks.child(`${blockId}/${path}`).set(text);
    }

    return null;
  }

  // initialize blocks from firebase databse after first render
  const [initializedFromDB, setInitializedFromDB] = React.useState(false);
  React.useEffect(() => {
    if (db !== 'firebase') return;
    if (initializedFromDB) return;

    dbBlocks.on('value', (snapshot) => {
      const blocksObject = snapshot.val();
      // firebase stores everything as objects, so we need to convert the blocks
      // object back to an array (blockId is the key auto-generated by firebase)
      const blocks = Object.keys(blocksObject).map((blockId) => {
        const block = blocksObject[blockId];
        return {
          id: blockId,
          meta: block.meta,
          type: block.type,
          body: block.body,
        };
      });

      setInitializedFromDB(true);
      setBlocks(blocks);
    });
  }, [db, dbBlocks, initializedFromDB]);

  return (
    <BlocksContext.Provider
      value={{ blocks, addBlock, removeBlock, updateBlockFieldText }}
    >
      {children}
    </BlocksContext.Provider>
  );
}

export { BlocksContext, BlocksProvider };
export type { BlockProps };
