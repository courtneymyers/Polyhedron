// @flow

import React from 'react';
// types
import type { Node } from 'react';
import type { Database } from 'components/App';
// utilities
import { setKeyValue } from 'utilities';
// databases
import firebase, { version } from 'databases/firebase.js';

// --- contexts
export const BlocksContext: any = React.createContext();

// --- components
type Props = {|
  db: Database,
  children: Node,
  // context props
  userId: ?string,
|};

export type BlockProps = {|
  id: string,
  meta: {|
    time: number,
    title: string,
    desc: string,
  |},
  type: 'plainText' | 'richText',
  body: string,
|};

type State = {|
  blocks: Array<BlockProps>,
  addBlock: () => string,
  removeBlock: (blockId: string) => void,
  updateBlockFieldText: (blockId: string, field: string, text: string) => void,
|};

export class BlocksProvider extends React.Component<Props, State> {
  state: State = {
    blocks: [],
    addBlock: () => {
      return this.addBlock();
    },
    removeBlock: (blockId) => {
      return this.removeBlock(blockId);
    },
    updateBlockFieldText: (blockId, field, text) => {
      return this.updateBlockFieldText(blockId, field, text);
    },
  };

  //
  dbBlocks: Object = firebase
    .database()
    .ref(`version/${version}/users/${this.props.userId}`)
    .child('blocks');

  addBlock = () => {
    const currentTime = new Date().getTime();

    if (this.props.db === 'memory') {
      this.setState((prevState) => ({
        blocks: prevState.blocks.concat({
          id: currentTime.toString(),
          meta: {
            time: currentTime,
            title: '',
            desc: '',
          },
          type: 'plainText',
          body: '',
        }),
      }));

      return currentTime.toString();
    }

    if (this.props.db === 'firebase') {
      const newBlock = this.dbBlocks.push({
        meta: {
          time: currentTime,
          title: '',
          desc: '',
        },
        type: 'plainText',
        body: '',
      });

      return newBlock.key;
    }

    return '';
  };

  removeBlock = (blockId: string) => {
    if (this.props.db === 'memory') {
      this.setState((prevState) => ({
        blocks: prevState.blocks.filter((block) => block.id !== blockId),
      }));
    }

    if (this.props.db === 'firebase') {
      const dbBlock = this.dbBlocks.child(blockId);
      dbBlock.remove();
    }

    return;
  };

  updateBlockFieldText = (blockId: string, field: string, text: string) => {
    const fields = field.split('.'); // 'meta.title' -> ['meta', 'title']

    if (this.props.db === 'memory') {
      this.setState((prevState) => {
        const blocks = [...prevState.blocks];
        const block = blocks.filter((block) => block.id === blockId)[0];
        setKeyValue(block, fields, text);

        return {
          blocks: blocks,
        };
      });
    }

    if (this.props.db === 'firebase') {
      const path = fields.join('/'); // ['meta', 'title'] -> 'meta/title'
      this.dbBlocks.child(`${blockId}/${path}`).set(text);
    }

    return;
  };

  componentDidMount() {
    if (this.props.db === 'firebase') {
      this.dbBlocks.on('value', (snapshot) => {
        const blocks = snapshot.val();
        // firebase stores everything as objects, so we need to convert the
        // blocks data back to an array by iterating over each object's key
        // (blocksKey below is the key auto-generated by firebase)
        let updatedBlocks = [];
        for (let blocksKey in blocks) {
          const block = blocks[blocksKey];

          updatedBlocks.push({
            id: blocksKey,
            meta: block.meta,
            type: block.type,
            body: block.body,
          });
        }

        this.setState((prevState) => ({
          blocks: updatedBlocks,
        }));
      });
    }
  }

  render() {
    return (
      <BlocksContext.Provider value={this.state}>
        {this.props.children}
      </BlocksContext.Provider>
    );
  }
}
